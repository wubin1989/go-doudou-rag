/**
* Generated by go-doudou v2.5.9.
* You can edit it as your need.
 */
package service

import (
	"context"
	"encoding/base64"
	"fmt"
	"image"
	"image/color"
	"image/png"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"time"

	"github.com/klippa-app/go-pdfium"
	"github.com/klippa-app/go-pdfium/enums"
	"github.com/klippa-app/go-pdfium/requests"
	"github.com/klippa-app/go-pdfium/webassembly"
	"github.com/lithammer/shortuuid/v4"
	"github.com/philippgille/chromem-go"
	"github.com/samber/lo"
	"github.com/spf13/cast"
	"github.com/tmc/langchaingo/llms/openai"
	"github.com/tmc/langchaingo/schema"
	"github.com/tmc/langchaingo/textsplitter"
	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
	"github.com/unionj-cloud/toolkit/stringutils"

	"go-doudou-rag/module-knowledge/config"
	"go-doudou-rag/module-knowledge/dto"
	"go-doudou-rag/module-knowledge/internal/dao"
	"go-doudou-rag/module-knowledge/internal/model"
)

var pool pdfium.Pool
var instance pdfium.Pdfium

func init() {
	var err error

	// Init the PDFium library and return the instance to open documents.
	// You can tweak these configs to your need. Be aware that workers can use quite some memory.
	pool, err = webassembly.Init(webassembly.Config{
		MinIdle:  1, // Makes sure that at least x workers are always available
		MaxIdle:  1, // Makes sure that at most x workers are ever available
		MaxTotal: 1, // Maxium amount of workers in total, allows the amount of workers to grow when needed, items between total max and idle max are automatically cleaned up, while idle workers are kept alive so they can be used directly.
	})
	if err != nil {
		log.Fatal(err)
	}

	instance, err = pool.GetInstance(time.Second * 30)
	if err != nil {
		log.Fatal(err)
	}
}

var _ ModuleKnowledge = (*ModuleKnowledgeImpl)(nil)

type ModuleKnowledgeImpl struct {
	conf        *config.Config
	collection  *chromem.Collection
	vectorStore *chromem.DB
}

func NewModuleKnowledge(conf *config.Config) *ModuleKnowledgeImpl {
	db := chromem.NewDB()
	db.ImportFromFile(conf.Biz.VectorStore.ExportToFile, "")

	embeddingFunc := chromem.NewEmbeddingFuncOpenAICompat(conf.Openai.BaseUrl,
		lo.Ternary(stringutils.IsNotEmpty(conf.Openai.Token), conf.Openai.Token, os.Getenv("OPENAI_API_KEY")),
		conf.Openai.EmbeddingModel, nil)
	c, err := db.GetOrCreateCollection("knowledge-base", nil, embeddingFunc)
	if err != nil {
		panic(err)
	}

	return &ModuleKnowledgeImpl{
		conf:        conf,
		collection:  c,
		vectorStore: db,
	}
}

func (receiver *ModuleKnowledgeImpl) Upload(ctx context.Context, file v3.FileModel) (data dto.UploadResult, err error) {
	defer func() {
		file.Close()
	}()

	if filepath.Ext(file.Filename) != ".pdf" {
		panic("not a pdf file")
	}

	_ = os.MkdirAll(receiver.conf.Biz.FileSavePath, os.ModePerm)
	out := filepath.Join(receiver.conf.Biz.FileSavePath, file.Filename)
	var f *os.File
	f, err = os.OpenFile(out, os.O_WRONLY|os.O_CREATE, os.ModePerm)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	_, err = io.Copy(f, file.Reader)
	if err != nil {
		panic(err)
	}

	doc, err := instance.FPDF_LoadDocument(&requests.FPDF_LoadDocument{
		Path: &out,
	})
	if err != nil {
		panic(err)
	}

	// Always close the document, this will release its resources.
	defer instance.FPDF_CloseDocument(&requests.FPDF_CloseDocument{
		Document: doc.Document,
	})

	pageCount, err := instance.FPDF_GetPageCount(&requests.FPDF_GetPageCount{
		Document: doc.Document,
	})
	if err != nil {
		panic(err)
	}

	var docs []schema.Document

	for i := 0; i < pageCount.PageCount; i++ {
		objCount, err := instance.FPDFPage_CountObjects(&requests.FPDFPage_CountObjects{
			Page: requests.Page{
				ByIndex: &requests.PageByIndex{
					Document: doc.Document,
					Index:    i,
				},
			},
		})
		if err != nil {
			panic(err)
		}

		for j := 0; j < objCount.Count; j++ {
			obj, err := instance.FPDFPage_GetObject(&requests.FPDFPage_GetObject{
				Page: requests.Page{
					ByIndex: &requests.PageByIndex{
						Document: doc.Document,
						Index:    i,
					},
				},
				Index: j,
			})
			if err != nil {
				panic(err)
			}

			objType, err := instance.FPDFPageObj_GetType(&requests.FPDFPageObj_GetType{
				PageObject: obj.PageObject,
			})
			if err != nil {
				panic(err)
			}

			if objType.Type == enums.FPDF_PAGEOBJ_IMAGE {
				getBitmap, err := instance.FPDFImageObj_GetBitmap(&requests.FPDFImageObj_GetBitmap{
					ImageObject: obj.PageObject,
				})
				if err != nil {
					panic(err)
				}

				bitmapBuffer, err := instance.FPDFBitmap_GetBuffer(&requests.FPDFBitmap_GetBuffer{
					Bitmap: getBitmap.Bitmap,
				})
				if err != nil {
					panic(err)
				}

				output := filepath.Join(receiver.conf.Biz.FileSavePath, fmt.Sprintf("%d_%d.png", i, j))

				getWidth, err := instance.FPDFBitmap_GetWidth(&requests.FPDFBitmap_GetWidth{
					Bitmap: getBitmap.Bitmap,
				})
				if err != nil {
					panic(err)
				}

				getHeight, err := instance.FPDFBitmap_GetHeight(&requests.FPDFBitmap_GetHeight{
					Bitmap: getBitmap.Bitmap,
				})
				if err != nil {
					panic(err)
				}

				getStride, err := instance.FPDFBitmap_GetStride(&requests.FPDFBitmap_GetStride{
					Bitmap: getBitmap.Bitmap,
				})
				if err != nil {
					panic(err)
				}

				getImageFilterCount, err := instance.FPDFImageObj_GetImageFilterCount(&requests.FPDFImageObj_GetImageFilterCount{
					ImageObject: obj.PageObject,
				})
				if err != nil {
					panic(err)
				}
				for k := 0; k < getImageFilterCount.Count; k++ {
					getImageFilter, err := instance.FPDFImageObj_GetImageFilter(&requests.FPDFImageObj_GetImageFilter{
						ImageObject: obj.PageObject,
						Index:       k,
					})
					if err != nil {
						panic(err)
					}
					fmt.Println(k, ":", getImageFilter.ImageFilter)
				}

				saveBitmapToPNG(bitmapBuffer.Buffer, int(getWidth.Width), int(getHeight.Height), output, getStride.Stride)

				instance.FPDFBitmap_Destroy(&requests.FPDFBitmap_Destroy{
					Bitmap: getBitmap.Bitmap,
				})

				//text := receiver.analyzeImageWithMultiModal(ctx, output)
				//
				//docs = append(docs, schema.Document{
				//	PageContent: text,
				//	Metadata: map[string]any{
				//		"page":        i,
				//		"total_pages": pageCount.PageCount,
				//		"type":        "image",
				//	},
				//})
			}
		}

		// 获取页面文本
		pageText, err := instance.GetPageText(&requests.GetPageText{
			Page: requests.Page{
				ByIndex: &requests.PageByIndex{
					Document: doc.Document,
					Index:    i,
				},
			},
		})
		if err != nil {
			panic(err)
		}

		docs = append(docs, schema.Document{
			PageContent: pageText.Text,
			Metadata: map[string]any{
				"page":        i,
				"total_pages": pageCount.PageCount,
				"type":        "text",
			},
		})
	}

	splitter := textsplitter.NewRecursiveCharacter(
		textsplitter.WithChunkSize(500),
		textsplitter.WithChunkOverlap(100),
	)

	// 分割文档
	splitDocs, err := textsplitter.SplitDocuments(splitter, docs)
	if err != nil {
		panic(err)
	}

	var documents []chromem.Document
	lo.ForEach(splitDocs, func(item schema.Document, index int) {
		metadata := lo.MapEntries[string, any, string, string](item.Metadata, func(key string, value any) (string, string) {
			return key, cast.ToString(value)
		})

		metadata["file"] = out

		documents = append(documents, chromem.Document{
			ID:       shortuuid.New(),
			Content:  item.PageContent,
			Metadata: metadata,
		})
	})

	if err = receiver.collection.AddDocuments(ctx, documents, runtime.NumCPU()); err != nil {
		panic(err)
	}

	if err = receiver.vectorStore.ExportToFile(receiver.conf.Biz.VectorStore.ExportToFile, false, ""); err != nil {
		panic(err)
	}

	fileRepo := dao.GetFileRepo()
	id := fileRepo.Save(ctx, dto.FileDTO{
		Path: out,
	})

	return dto.UploadResult{
		Id: id,
	}, nil
}

func (receiver *ModuleKnowledgeImpl) GetList(ctx context.Context, req dto.GetListReq) (data []dto.FileDTO, _ error) {
	fileRepo := dao.GetFileRepo()

	listReq := dao.ListReq{
		FileId: req.FileId,
	}
	fileModels := fileRepo.List(ctx, listReq)

	lo.ForEach(fileModels, func(item *model.File, index int) {

		var content string

		if req.WithContent {
			doc, err := instance.FPDF_LoadDocument(&requests.FPDF_LoadDocument{
				Path: &item.Path,
			})
			if err != nil {
				panic(err)
			}

			// Always close the document, this will release its resources.
			defer instance.FPDF_CloseDocument(&requests.FPDF_CloseDocument{
				Document: doc.Document,
			})

			pageCount, err := instance.FPDF_GetPageCount(&requests.FPDF_GetPageCount{
				Document: doc.Document,
			})
			if err != nil {
				panic(err)
			}

			for i := 0; i < pageCount.PageCount; i++ {
				pageText, err := instance.GetPageText(&requests.GetPageText{
					Page: requests.Page{
						ByIndex: &requests.PageByIndex{
							Document: doc.Document,
							Index:    i,
						},
					},
				})
				if err != nil {
					panic(err)
				}

				content += pageText.Text
			}
		}

		data = append(data, dto.FileDTO{
			Id:      item.ID,
			Path:    item.Path,
			Content: content,
		})
	})

	return data, nil
}

func (receiver *ModuleKnowledgeImpl) GetQuery(ctx context.Context, req dto.QueryReq) (data []dto.QueryResult, err error) {
	if stringutils.IsEmpty(req.Text) {
		panic("empty text")
	}

	nResults := 1
	if req.Top > 0 {
		nResults = req.Top
	}

	res, err := receiver.collection.Query(ctx, req.Text, nResults, nil, nil)
	if err != nil {
		panic(err)
	}

	lo.ForEach(res, func(item chromem.Result, index int) {
		data = append(data, dto.QueryResult{
			ID:         item.ID,
			Similarity: cast.ToString(item.Similarity),
			Content:    item.Content,
		})
	})

	return data, nil
}

// analyzeImageWithMultiModal 使用多模态大模型分析图片，提取文字并描述图片内容
func (receiver *ModuleKnowledgeImpl) analyzeImageWithMultiModal(ctx context.Context, file string) string {

	imgData, err := os.ReadFile(file)
	if err != nil {
		panic(err)
	}

	contentType := http.DetectContentType(imgData)

	// 将图片转换为Base64
	imgBase64 := base64.StdEncoding.EncodeToString(imgData)

	// 初始化OpenAI客户端 (使用GPT-4 Vision或其他多模态模型)
	// 从配置中获取API密钥
	openaiClient, err := openai.New(
		openai.WithBaseURL(receiver.conf.Openai.BaseUrl),
		openai.WithToken(lo.Ternary(stringutils.IsNotEmpty(receiver.conf.Openai.Token), receiver.conf.Openai.Token, os.Getenv("OPENAI_API_KEY"))),
		openai.WithEmbeddingModel(receiver.conf.Openai.EmbeddingModel),
		openai.WithModel(receiver.conf.Openai.Model),
	)

	if err != nil {
		panic(fmt.Errorf("初始化OpenAI客户端失败: %w", err))
	}

	// 创建包含图片的提示
	// 注意: 这里的实现依赖于OpenAI的Vision API
	// 其他模型可能需要不同的实现方式
	prompt := fmt.Sprintf(`以下是一张图片。请执行两项任务:
1. 如果图片包含任何文字，请提取并返回所有可见文字。
2. 详细描述图片中显示的内容。

请按以下格式返回:
文字: [图片中的所有文字，如果没有则返回"无文字"]
描述: [对图片内容的详细描述]

图片数据: data:%s;base64,%s`, contentType, imgBase64)

	// 发送请求到模型
	response, err := openaiClient.Call(ctx, prompt)
	if err != nil {
		panic(fmt.Errorf("发送请求到模型失败: %w", err))
	}

	return response
}

func saveBitmapToPNG(rgba []byte, width, height int, filename string, stride int) {
	// 创建RGBA图像
	img := image.NewRGBA(image.Rect(0, 0, width, height))

	// 遍历图像的每个像素
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			// 计算像素在缓冲区中的位置
			i := y*stride + x*4

			// PDFium使用BGRA格式，需要转换为RGBA
			b := rgba[i+0]
			g := rgba[i+1]
			r := rgba[i+2]
			a := rgba[i+3]

			// 设置像素值
			img.Set(x, y, color.RGBA{R: r, G: g, B: b, A: a})
		}
	}

	// 创建输出文件
	outFile, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer outFile.Close()

	// 编码并保存
	if err = png.Encode(outFile, img); err != nil {
		panic(err)
	}
}
