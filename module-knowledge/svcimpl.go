/**
* Generated by go-doudou v2.5.9.
* You can edit it as your need.
 */
package service

import (
	"context"
	"go-doudou-rag/module-knowledge/config"
	"go-doudou-rag/module-knowledge/dto"
	"go-doudou-rag/module-knowledge/internal/dao"
	"go-doudou-rag/module-knowledge/internal/model"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"time"

	"github.com/unionj-cloud/toolkit/stringutils"

	"github.com/klippa-app/go-pdfium/requests"
	"github.com/klippa-app/go-pdfium/webassembly"
	"github.com/lithammer/shortuuid/v4"
	"github.com/spf13/cast"

	"github.com/klippa-app/go-pdfium"
	"github.com/philippgille/chromem-go"
	"github.com/samber/lo"
	"github.com/tmc/langchaingo/schema"
	"github.com/tmc/langchaingo/textsplitter"
	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
)

var pool pdfium.Pool
var instance pdfium.Pdfium

func init() {
	var err error

	// Init the PDFium library and return the instance to open documents.
	// You can tweak these configs to your need. Be aware that workers can use quite some memory.
	pool, err = webassembly.Init(webassembly.Config{
		MinIdle:  1, // Makes sure that at least x workers are always available
		MaxIdle:  1, // Makes sure that at most x workers are ever available
		MaxTotal: 1, // Maxium amount of workers in total, allows the amount of workers to grow when needed, items between total max and idle max are automatically cleaned up, while idle workers are kept alive so they can be used directly.
	})
	if err != nil {
		log.Fatal(err)
	}

	instance, err = pool.GetInstance(time.Second * 30)
	if err != nil {
		log.Fatal(err)
	}
}

var _ ModuleKnowledge = (*ModuleKnowledgeImpl)(nil)

type ModuleKnowledgeImpl struct {
	conf        *config.Config
	collection  *chromem.Collection
	vectorStore *chromem.DB
}

func NewModuleKnowledge(conf *config.Config) *ModuleKnowledgeImpl {
	db := chromem.NewDB()
	db.ImportFromFile(conf.Biz.VectorStore.ExportToFile, "")

	embeddingFunc := chromem.NewEmbeddingFuncOpenAICompat(conf.Openai.BaseUrl,
		lo.Ternary(stringutils.IsNotEmpty(conf.Openai.Token), conf.Openai.Token, os.Getenv("OPENAI_API_KEY")),
		conf.Openai.EmbeddingModel, nil)
	c, err := db.GetOrCreateCollection("knowledge-base", nil, embeddingFunc)
	if err != nil {
		panic(err)
	}

	return &ModuleKnowledgeImpl{
		conf:        conf,
		collection:  c,
		vectorStore: db,
	}
}

func (receiver *ModuleKnowledgeImpl) Upload(ctx context.Context, file v3.FileModel) (data dto.UploadResult, err error) {
	defer func() {
		file.Close()
	}()

	if filepath.Ext(file.Filename) != ".pdf" {
		panic("not a pdf file")
	}

	_ = os.MkdirAll(receiver.conf.Biz.FileSavePath, os.ModePerm)
	out := filepath.Join(receiver.conf.Biz.FileSavePath, file.Filename)
	var f *os.File
	f, err = os.OpenFile(out, os.O_WRONLY|os.O_CREATE, os.ModePerm)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	_, err = io.Copy(f, file.Reader)
	if err != nil {
		panic(err)
	}

	doc, err := instance.FPDF_LoadDocument(&requests.FPDF_LoadDocument{
		Path: &out,
	})
	if err != nil {
		panic(err)
	}

	// Always close the document, this will release its resources.
	defer instance.FPDF_CloseDocument(&requests.FPDF_CloseDocument{
		Document: doc.Document,
	})

	pageCount, err := instance.FPDF_GetPageCount(&requests.FPDF_GetPageCount{
		Document: doc.Document,
	})
	if err != nil {
		panic(err)
	}

	var docs []schema.Document

	for i := 0; i < pageCount.PageCount; i++ {
		pageText, err := instance.GetPageText(&requests.GetPageText{
			Page: requests.Page{
				ByIndex: &requests.PageByIndex{
					Document: doc.Document,
					Index:    i,
				},
			},
		})
		if err != nil {
			panic(err)
		}

		docs = append(docs, schema.Document{
			PageContent: pageText.Text,
			Metadata: map[string]any{
				"page":        i,
				"total_pages": pageCount.PageCount,
			},
		})
	}

	splitter := textsplitter.NewRecursiveCharacter(
		textsplitter.WithChunkSize(500),
		textsplitter.WithChunkOverlap(100),
	)

	// 分割文档
	splitDocs, err := textsplitter.SplitDocuments(splitter, docs)
	if err != nil {
		panic(err)
	}

	var documents []chromem.Document
	lo.ForEach(splitDocs, func(item schema.Document, index int) {
		metadata := lo.MapEntries[string, any, string, string](item.Metadata, func(key string, value any) (string, string) {
			return key, cast.ToString(value)
		})

		metadata["file"] = out

		documents = append(documents, chromem.Document{
			ID:       shortuuid.New(),
			Content:  item.PageContent,
			Metadata: metadata,
		})
	})

	if err = receiver.collection.AddDocuments(ctx, documents, runtime.NumCPU()); err != nil {
		panic(err)
	}

	if err = receiver.vectorStore.ExportToFile(receiver.conf.Biz.VectorStore.ExportToFile, false, ""); err != nil {
		panic(err)
	}

	fileRepo := dao.GetFileRepo()
	id := fileRepo.Save(ctx, dto.FileDTO{
		Path: out,
	})

	return dto.UploadResult{
		Id: id,
	}, nil
}

func (receiver *ModuleKnowledgeImpl) GetList(ctx context.Context, req dto.GetListReq) (data []dto.FileDTO, _ error) {
	fileRepo := dao.GetFileRepo()

	listReq := dao.ListReq{
		FileId: req.FileId,
	}
	fileModels := fileRepo.List(ctx, listReq)

	lo.ForEach(fileModels, func(item *model.File, index int) {

		var content string

		if req.WithContent {
			doc, err := instance.FPDF_LoadDocument(&requests.FPDF_LoadDocument{
				Path: &item.Path,
			})
			if err != nil {
				panic(err)
			}

			// Always close the document, this will release its resources.
			defer instance.FPDF_CloseDocument(&requests.FPDF_CloseDocument{
				Document: doc.Document,
			})

			pageCount, err := instance.FPDF_GetPageCount(&requests.FPDF_GetPageCount{
				Document: doc.Document,
			})
			if err != nil {
				panic(err)
			}

			for i := 0; i < pageCount.PageCount; i++ {
				pageText, err := instance.GetPageText(&requests.GetPageText{
					Page: requests.Page{
						ByIndex: &requests.PageByIndex{
							Document: doc.Document,
							Index:    i,
						},
					},
				})
				if err != nil {
					panic(err)
				}

				content += pageText.Text
			}
		}

		data = append(data, dto.FileDTO{
			Id:      item.ID,
			Path:    item.Path,
			Content: content,
		})
	})

	return data, nil
}

func (receiver *ModuleKnowledgeImpl) GetQuery(ctx context.Context, req dto.QueryReq) (data []dto.QueryResult, err error) {
	if stringutils.IsEmpty(req.Text) {
		panic("empty text")
	}

	nResults := 1
	if req.Top > 0 {
		nResults = req.Top
	}

	res, err := receiver.collection.Query(ctx, req.Text, nResults, nil, nil)
	if err != nil {
		panic(err)
	}

	lo.ForEach(res, func(item chromem.Result, index int) {
		data = append(data, dto.QueryResult{
			ID:         item.ID,
			Similarity: cast.ToString(item.Similarity),
			Content:    item.Content,
		})
	})

	return data, nil
}
