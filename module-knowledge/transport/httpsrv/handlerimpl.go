/**
* Generated by go-doudou v2.5.9.
* You can edit it as your need.
 */
package httpsrv

import (
	"context"
	"errors"
	service "go-doudou-rag/module-knowledge"
	"go-doudou-rag/module-knowledge/dto"
	"net/http"

	"github.com/bytedance/sonic"
	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
	v3 "github.com/unionj-cloud/toolkit/openapi/v3"
)

var json = sonic.ConfigDefault

type ModuleKnowledgeHandlerImpl struct {
	moduleKnowledge service.ModuleKnowledge
}

func (receiver *ModuleKnowledgeHandlerImpl) Upload(_writer http.ResponseWriter, _req *http.Request) {
	var (
		ctx  context.Context
		file v3.FileModel
		data dto.UploadResult
		err  error
	)
	ctx = _req.Context()
	if _err := _req.ParseMultipartForm(32 << 20); _err != nil {
		rest.HandleBadRequestErr(_err)
	}
	fileFileHeaders, exists := _req.MultipartForm.File["file"]
	if exists {
		if len(fileFileHeaders) == 0 {
			rest.HandleBadRequestErr(errors.New("no file uploaded for parameter file"))
		}
		if len(fileFileHeaders) > 0 {
			_fh := fileFileHeaders[0]
			_f, _err := _fh.Open()
			if _err != nil {
				rest.HandleBadRequestErr(_err)
			}
			file = v3.FileModel{
				Filename: _fh.Filename,
				Reader:   _f,
			}
		}
	} else {
		rest.HandleBadRequestErr(errors.New("missing parameter file"))
	}
	data, err = receiver.moduleKnowledge.Upload(
		ctx,
		file,
	)
	if err != nil {
		panic(err)
	}
	_writer.Header().Set("Content-Type", "application/json; charset=UTF-8")
	if _err := json.NewEncoder(_writer).Encode(struct {
		Data dto.UploadResult `json:"data"`
	}{
		Data: data,
	}); _err != nil {
		rest.HandleInternalServerError(_err)
	}
}

func (receiver *ModuleKnowledgeHandlerImpl) GetQuery(_writer http.ResponseWriter, _req *http.Request) {
	var (
		ctx  context.Context
		req  dto.QueryReq
		data []dto.QueryResult
		err  error
	)
	ctx = _req.Context()
	if _err := _req.ParseForm(); _err != nil {
		rest.HandleBadRequestErr(_err)
	}
	if _err := rest.DecodeForm(&req, _req.Form); _err != nil {
		rest.HandleBadRequestErr(_err)
	} else {
		if _err := rest.ValidateStruct(req); _err != nil {
			rest.HandleBadRequestErr(_err)
		}
	}
	data, err = receiver.moduleKnowledge.GetQuery(
		ctx,
		req,
	)
	if err != nil {
		panic(err)
	}
	_writer.Header().Set("Content-Type", "application/json; charset=UTF-8")
	if _err := json.NewEncoder(_writer).Encode(struct {
		Data []dto.QueryResult `json:"data"`
	}{
		Data: data,
	}); _err != nil {
		rest.HandleInternalServerError(_err)
	}
}

func NewModuleKnowledgeHandler(moduleKnowledge service.ModuleKnowledge) ModuleKnowledgeHandler {
	return &ModuleKnowledgeHandlerImpl{
		moduleKnowledge,
	}
}

func (receiver *ModuleKnowledgeHandlerImpl) GetList(_writer http.ResponseWriter, _req *http.Request) {
	var (
		ctx  context.Context
		req  dto.GetListReq
		data []dto.FileDTO
		err  error
	)
	ctx = _req.Context()
	if _err := _req.ParseForm(); _err != nil {
		rest.HandleBadRequestErr(_err)
	}
	if _err := rest.DecodeForm(&req, _req.Form); _err != nil {
		rest.HandleBadRequestErr(_err)
	} else {
		if _err := rest.ValidateStruct(req); _err != nil {
			rest.HandleBadRequestErr(_err)
		}
	}
	data, err = receiver.moduleKnowledge.GetList(
		ctx,
		req,
	)
	if err != nil {
		panic(err)
	}
	_writer.Header().Set("Content-Type", "application/json; charset=UTF-8")
	if _err := json.NewEncoder(_writer).Encode(struct {
		Data []dto.FileDTO `json:"data"`
	}{
		Data: data,
	}); _err != nil {
		rest.HandleInternalServerError(_err)
	}
}
